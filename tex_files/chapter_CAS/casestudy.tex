\section{Case Study}
\label{sec:CAS_castudy}

In this section the design and the implementation of a blog platform is presented.

\subsection{1st step - Models schemas definition}

As to a blog platform, the essential entities to be modelled are the following: Post and Tag.

\begin{lstlisting}[language=javascript]
{
	"name": "Post",
	"properties": {
		"title": {"type":"string"},
		"posted": {"type":"date"},
		"content": {"type":"text"},
		"permalink": {"type":"string"}
	},
	"relations": {
		"tags": {"type":"has_many","model":"Tag"}
	}
}
\end{lstlisting}

\begin{lstlisting}[language=javascript]
{
	"name": "Tag",
	"properties": {
		"name": {"type":"string"}
	}
}
\end{lstlisting}

\subsection{2nd step - HTTP RESTful API definition}

These models result in the following HTTP RESTful API, automatically generated by Loopback server.

\begin{lstlisting}[language=javascript]
	GET / api / Posts
	POST / api / Posts
	GET / api / Posts /: post_id
	PUT / api / Posts /: post_id
	DELETE / api / Posts /: post_id
	GET / api / Tags
	POST / api / Tags
	GET / api / Tags /: tag_id
	PUT / api / Tags /: tag_id
	DELETE / api / Tags /: tag_id
\end{lstlisting}

\subsection{3rd step - UI components definition}

In this simple example, there is no need to define further components besides the ones provided by the x-project toolkit.

\subsection{4th step - UI components assembly}

Since a snippet is worth a thousand words, in the following the code of the pages of the app is shown. It is important to remark how easily a page can be built without writing code but assembling elements.

Tha admin part is composed by page-collection and page-model-edit. These pages are accessible via the following routes.

\begin{lstlisting}[language=html]
<x-router>
	<x-route route="/admin/:collection"page="page-collection"/>
	<x-route route="/admin/:collection/:id"page="page-model-edit"/>
</x-router>
\end{lstlisting}

Where: the parameter :collection is the name of the collection to inspect; the parameter :id is the id of the model to edit. These parameters are set as attributes of the page element.

\begin{itemize} \texttt{<page-collection>} Shows the models of a collection.

\begin{lstlisting}[language=html]
<template name= "page-collection">
	<api-collection-schema name="{{collection}}" 
	schema="{{schema}" />
	<api-collection-get name="{{collection}}" 
	where="{{where}}" page="{{page}}" perpage="{{perpage}}"
	items="{{items}}" count="{{count}}"/>
	<api-collection-where schema="{{schema}}" 
	where="{{where}}"/>
	<x-table schema="{{schema}}" items="{{items}}" />
	<x-pager count="{{count}}" perpage="{{perpage}}" 
	current="{{page}}"/>
</template>
\end{lstlisting}

Where: the value collection is picked from the url, via the parameter :collection; the value schema is the output of \texttt{<api-collection-schema>} and the input of \texttt{<api-collection-get>} and \texttt{<x-table>}; the value items is the output of \texttt{<api-collection-get>} and the input of \texttt{<x-table>}; the value where is the output of \texttt{<api-collection-where>} and the input of \texttt{<api-collection-get>}; the value count is the output of \texttt{<api-collection-get>} and the input of \texttt{<x-pager>}; the values perpage and page are the outputs of \texttt{<x-pager>} and the inputs of \texttt{<api-collection-get>}; every time the user (the admin) interacts with the pagination (<x-pager>) or the advanced search options (<api-collection-where>), \texttt{<api-collection-get>} regenerates the request to get the list of models using pagination and query parameters.

\end{itemize}
