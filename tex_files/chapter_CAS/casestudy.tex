\section{Case Study}
\label{sec:CAS_castudy}

In this section the design and the implementation of a blog platform is presented.

\subsection{1st step - Models schemas definition}

As to a blog platform, the essential entities to be modelled are the following: Article, Tag and Author.

\subsubsection{Model - Article}

Il modello articolo definisce la struttura principale del post che si intende pubblicare, tra le porprietà principali: il titolo dell'articolo il contenuto e le date di  creazione, aggiornamento e pubblicazione. Questo modello ha delle relazioni con il modello autore, categoria, tag e immagine.

\begin{lstlisting}[language=html]
{
	"name": "Article",
	"properties": {
		"title": {
      		"type": "string"
    	},
    	"subtitle": {
      		"type": "string"
    	},
    	"summary": {
      		"type": "string"
    	},
    	"content": {
      		"type": "string"
    	},
    	"created_at": {
      		"type": "date"
    	},
    	"updated_at": {
      		"type": "date"
    	},
    	"published_at": {
      		"type": "date"
    	}
  	},
	"relations": {
    	"author": {
      		"type": "belongsTo",
      		"model": "Author"
    	},
    	"category": {
      		"type": "belongsTo",
      		"model": "Category"
    	},
    	"tags": {
      		"type": "hasMany",
      		"model": "Tag"
    	},
    	"image": {
      		"type": "hasOne",
      		"model": "Image"
    	}
    }
}
\end{lstlisting}
\subsubsection{Model - Tag}

Il modello tag rappresenta la parole chiave o un termine associato a quel specifico articolo, in modo da renderlo classificabile e indicizzato alle ricerche,

\begin{lstlisting}[language=html]
{
	"name": "Tag",
	"properties": {
		"name": {
			"type":"string"
		}
	}
}
\end{lstlisting}
\subsubsection{Model - Author}

Questo modello rappresenta il creatore dell'articolo, tra le varie proprietà: nome, ruolo, e il nome per esteso.
Autore ha delle relazione con altri autori, con delle categorie e anche con tag e immagini.

\begin{lstlisting}[language=html]
{
	"name": "Author",
	"properties": {
		"name": {"type":"string"},
    	"role": {"type": "string"},
    	"fullname": {"type": "string"},
    	"location": {"type": "string"}
	}
	"relations": {
    	"author": {
     		"type": "belongsTo",
      		"model": "Author"
    	},
    	"category": {
      		"type": "belongsTo",
      		"model": "Category"
    	},
    	"tags": {
      		"type": "hasMany",
      		"model": "Tag"
    	},
    	"image": {
      		"type": "hasOne",
      		"model": "Image"
    }
}
\end{lstlisting}

\subsection{2nd step - HTTP RESTful API definition}

These models result in the following HTTP RESTful API, automatically generated by Loopback server.

\begin{lstlisting}[language=javascript]
	GET / api / Articles
	POST / api / Articles
	GET / api / Articles /: article_id
	PUT / api / Articles /: article_id
	DELETE / api / Articles /: article_id
	GET / api / Tags
	POST / api / Tags
	GET / api / Tags /: tag_id
	PUT / api / Tags /: tag_id
	DELETE / api / Tags /: tag_id
	GET / api / author
	POST / api / author
	GET / api / author /: tag_id
	PUT / api / author /: tag_id
	DELETE / api / author /: tag_id
\end{lstlisting}

\subsection{3rd step - UI components definition}

In this simple example, there is no need to define further components besides the ones provided by the x-project toolkit.

\subsection{4th step - UI components assembly}

Since a snippet is worth a thousand words, in the following the code of the pages of the app is shown. It is important to remark how easily a page can be built without writing code but assembling elements.

Tha admin part is composed by page-collection and page-model-edit. These pages are accessible via the following routes.

\begin{lstlisting}[language=html]
<x-router>
	<x-route route="/admin/:collection"page="page-collection"/>
	<x-route route="/admin/:collection/:id"page="page-model-edit"/>
</x-router>
\end{lstlisting}

Where: the parameter :collection is the name of the collection to inspect; the parameter :id is the id of the model to edit. These parameters are set as attributes of the page element.

\begin{itemize} \item \texttt{<page-collection>} Shows the models of a collection.
\begin{lstlisting}[language=html]
<template name= "page-collection">
	<api-collection-schema name="{{collection}}" 
	schema="{{schema}" />
	<api-collection-get name="{{collection}}" 
	where="{{where}}" page="{{page}}" perpage="{{perpage}}"
	items="{{items}}" count="{{count}}"/>
	<api-collection-where schema="{{schema}}" 
	where="{{where}}"/>
	<x-table schema="{{schema}}" items="{{items}}" />
	<x-pager count="{{count}}" perpage="{{perpage}}" 
	current="{{page}}"/>
</template>
\end{lstlisting}
\end{itemize}

Where: the value collection is picked from the url, via the parameter :collection; the value schema is the output of \texttt{<api-collection-schema>} and the input of \texttt{<api-collection-get>} and \texttt{<x-table>}; the value items is the output of \texttt{<api-collection-get>} and the input of \texttt{<x-table>}; the value where is the output of \texttt{<api-collection-where>} and the input of \texttt{<api-collection-get>}; the value count is the output of \texttt{<api-collection-get>} and the input of \texttt{<x-pager>}; the values perpage and page are the outputs of \texttt{<x-pager>} and the inputs of \texttt{<api-collection-get>}; every time the user (the admin) interacts with the pagination (\texttt{<x-pager>}) or the advanced search options (\texttt{<api-collection-where>}), \texttt{<api-collection-get>} regenerates the request to get the list of models using pagination and query parameters.


\begin{itemize} \item \texttt{<page-model-edit>} Shows the forms to update a model.
\begin{lstlisting}[language=html]
<template name="page-model-edit">
	<api-collection-schema name="{{collection}}"
	schema="{{schema}}"/>
	<api-model-get name="{{collection}"
	model-id="{{id}}" model="{{model}}"/>
	<x-form schema="{{schema}}" model="{{model}}"/>
	<api-model-put name="{{collection}}"
	model-id="{{id}}" model="{{model}}"/>
</template>
\end{lstlisting}
\end{itemize}

Where: the value schema is the output of \texttt{<api-collection-schema>} and the input of \texttt{<x-form>}; the value model is the output of \texttt{<api-model-get>} and \texttt{<x-form>} and the input of \texttt{<api-model-put>}. Once the page is ready (initialized and served by the local router): \texttt{<api-collection-schema>} fetch the schema; \texttt{<api-model-get>} fetch the model (a article or a tag) identified by id; \texttt{<x-form>} shows the form to edit the model. When the model changes (is updated via the form) \texttt{<api-model-put>} sends a request to the server to update the database (via the corresponding HTTP RESTful API).


The user part is essentially composed by two pages: page-articles and page-article.

\begin{lstlisting}[language=html]
<x-router>
	<x-route route="/"page=" page-articles"/>
	<x-route route="articles/:id" page=" page-article"/>
</x-router>
\end{lstlisting}

\begin{itemize} \item \texttt{<page-articles>} Shows the list of articles.
\begin{lstlisting}[language=html]
<template name="page-articles">
	<api-collection-get name="Article"
		perpage="10" page="{{page}}"
		items="{{articles}}" count="{{count}}"/>
	<template is="dom-repeat" items="{{articles}}">
		<li>{{item.title}} {{item.date}}</li>
	</template>
	<x-pager perpage="10" total="{{count}}"
		current="{{page}}"/>
</template>
\end{lstlisting}
\end{itemize}

Where: the value articles is the output of \texttt{<api-collection-get>} and the input of the \texttt{<template>} iterator; for each item in articles, a list item with the article info (title and publish-ing date) is printed; \texttt{<x-pager>} component is the same used in the page \texttt{<page-collection>}.

\begin{itemize} \item \texttt{<page-article>} Shows a article.
\begin{lstlisting}[language=html]
<template name="page-article">
	<api-model-get name="Articles" model-id="{{id}}"
	model="{{article}}"/>
	<h1>{{article.title}}</h1>
	<h2>by{{article.author}}</h2>
	<h3>on{{article.date}}</h3>
	<div>{{article.content}}</div>
</template>
\end{lstlisting}
\end{itemize}

Once \texttt{<api-model-get>} has fetched the article (identified by id), title, author, date and content of the article will be shown. It has been shown how to use \texttt{x-project} toolkit to build a simple blog application. It can be extended, adding new features, by following the 4-steps document-driven process: defining new models, generating corresponding API, defininig new UI components, assembling the UI. The growth of the complexity of the application does not affect the complexity of the development. x-project source code is published on GitHub at http://github.com/x-project.

