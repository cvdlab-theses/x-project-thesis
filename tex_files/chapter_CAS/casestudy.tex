\section{Case Study}
\label{sec:CAS_castudy}

In this section the design and the implementation of a blog platform is presented.

\subsection{1st step - Models schemas definition}

As to a blog platform, the essential entities to be modelled are the following: Article, Category and Author.

\subsubsection{Model - Article}

Il modello articolo definisce la struttura principale del post che si intende pubblicare, tra le porprietà principali: il titolo dell'articolo il contenuto e le date di  creazione, aggiornamento e pubblicazione. Questo modello ha delle relazioni con il modello autore, categoria, tag e immagine.

\begin{lstlisting}[language=json]
{
	"name": "Article",
	"properties": {
		"title": {
      		"type": "string"
    	},
    	"subtitle": {
      		"type": "string"
    	},
    	"summary": {
      		"type": "string"
    	},
    	"content": {
      		"type": "string"
    	},
    	"created_at": {
      		"type": "date"
    	},
    	"updated_at": {
      		"type": "date"
    	},
    	"published_at": {
      		"type": "date"
    	}
  	},
	"relations": {
    	"author": {
      		"type": "belongsTo",
      		"model": "Author"
    	},
    	"category": {
      		"type": "belongsTo",
      		"model": "Category"
    	},
    	"image": {
      		"type": "hasOne",
      		"model": "Image"
    	}
    }
}
\end{lstlisting}
\subsubsection{Model - Category}

Il modello tag rappresenta la parole chiave o un termine associato a quel specifico articolo, in modo da renderlo classificabile e indicizzato alle ricerche,

\begin{lstlisting}[language=json]
{
	"name": "Category",
	"properties": {
		"name": {
			"type":"string"
		}
	}
}
\end{lstlisting}
\subsubsection{Model - Author}

Questo modello rappresenta il creatore dell'articolo, tra le varie proprietà: nome, ruolo, e il nome per esteso.
Autore ha delle relazione con altri autori, con delle categorie e anche con tag e immagini.

\begin{lstlisting}[language=json]
{
	"name": "Author",
	"properties": {
		"name": {"type":"string"},
    	"role": {"type": "string"},
    	"fullname": {"type": "string"},
    	"location": {"type": "string"}
	}
	"relations": {
    	"articles": {
     		"type": "hasMany",
      		"model": "Article"
    }
}
\end{lstlisting}

\subsection{2nd step - HTTP RESTful API definition}

These models result in the following HTTP RESTful API, automatically generated by Loopback server.

\subsubsection{Authors API}

\texttt{\textbf{GET /api/Authors}} Find all instances of the model matched by filter from tha data source.

\texttt{\textbf{POST /api/Authors}} Update an existing model instance or insert a new one into the data source.

\texttt{\textbf{PUT /api/Authors}} Create a new instance of the model and persist it into the data source.

\texttt{\textbf{DELETE /api/Authors/{id}}} Delete a model instance by id from the data source.

\texttt{\textbf{POST /api/changeEmail}} Change email a model instance.

\texttt{\textbf{POST /api/changePassword}} Change password a model instance.

\texttt{\textbf{GET /api/count}} Count instances of the model matched by where from the data source.

\texttt{\textbf{POST /api/login}} Login a user with username/email and password.

\texttt{\textbf{POST /api/logout}} Logout a user with access token.

\texttt{\textbf{POST /api/reset}} Reset password for a user with email.

\texttt{\textbf{POST /api/update}} Update instances of the model matched by where from the data. source.

	
\subsubsection{Articles API}

\texttt{\textbf{GET /api/Articles}} Find all instances of the model matched by filter from tha data source.

\texttt{\textbf{POST /api/Articles}} Update an existing model instance or insert a new one into the data source.

\texttt{\textbf{PUT /api/Articles}} Create a new instance of the model and persist it into the data source.

\texttt{\textbf{DELETE /api/Articles/{id}}} Delete a model instance by id from the data source.

\texttt{\textbf{GET /api/Articles/{id}/author}} Fetches belongsTO relation author.

\texttt{\textbf{GET /api/Articles/{id}/category}} Fetches belongsTO relation category.

\texttt{\textbf{GET /api/Articles/{id}/image}} Fetches belongsTO relation image.

\texttt{\textbf{GET /api/Articles/count}} Count instances of the model matched by where from the data source.


\subsubsection{Categories API}

\texttt{\textbf{PUT /Categories}} Update an existing model instance or insert a new one into the data source.

\texttt{\textbf{GET /Categories}} Find all instances of the model matched by filter from the data source.

\texttt{\textbf{POST / Categories}} create a new instance and persist it into the data source.

\texttt{\textbf{GET / Categories/{id}/articles}} Queries articles of category.

\texttt{\textbf{POST / Categories/{id}/articles}} Creates a new instance in articles of this model.

\texttt{\textbf{DELETE / Categories/{id}/articles}} Deletes all aricles of this model.


\subsubsection{Images API}

\texttt{\textbf{POST /Images}} create a new instance and persist it into the data source.

\texttt{\textbf{PUT /Images}} Update an existing model instance or insert a new one into the data source.

\texttt{\textbf{GET /Images}} Find all instances of the model matched by filter from the data source.

\texttt{\textbf{POST /Images/upload}} Upload a new instances into data source.

\texttt{\textbf{GET /Images/{id}}} Find a model instance by id from the data source

\texttt{\textbf{PUT /Images/{id}}} Update attributes dor a model instance and persist it into the data source.

\texttt{\textbf{DELETE /Images/{id}}} Deletes a model instance by id from the data source.

\subsubsection{Remote Methods}

\subsubsection{Change Email}

\begin{lstlisting}[language=javascript]
Author.change_email = function (new_email, 
	confirm_email, password, cb) {
    if (new_email !== confirm_email) {
      cb({ error: 'email not confirmed' }, null);
      return;
    }

    var userId = getCurrentUserId();  

    Author.findById(userId, function (err, user) {
      if (err) {
        cb(err, null);
        return;
      }

      user.hasPassword(password, function (err, match) {
        if (!match) {
          cb({ error: 'invalid password' }, null);
          return;
        }

        user.updateAttribute('email', 
        	new_email, function (err, user) {
          if (err) {
            cb(err, null);
            return;
          }

          cb(null, true);
        });
	  });       
	});
};
   Author.remoteMethod('change_email', {
    http: { path: '/change_email', verb: 'post' },
    accepts: [
      { arg: 'new_email', type: 'string' },
      { arg: 'confirm_email', type: 'string' },
      { arg: 'password', type: 'string' }
    ],
    returns: { arg: 'changed', type: 'boolean' }
  });
\end{lstlisting}

\subsubsection{Change Password}

\begin{lstlisting}[language=javascript]
Author.change_password = function (new_password, 
	confirm_password, password, cb) {
    if (new_password !== confirm_password) {
      cb({ error: 'password not confirmed' }, null);
      return;
    }

    var userId = getCurrentUserId();  

    Author.findById(userId, function (err, user) {
      if (err) {
        cb(err, null);
        return;
      }

      user.hasPassword(password, function (err, match) {
        if (!match) {
          cb({ error: 'invalid password' }, null);
          return;
        }

        user.updateAttribute('password', new_password, 
        	function (err, user) {
          if (err) {
            cb(err, null);
            return;
          }

          cb(null, true);
        });
	  });       
    });
  };
   
  Author.remoteMethod('change_password', {
    http: { path: '/change_password', verb: 'post' },
    accepts: [
      { arg: 'new_password', type: 'string' },
      { arg: 'confirm_password', type: 'string' },
      { arg: 'password', type: 'string' }
    ],
    returns: { arg: 'changed', type: 'boolean' }
  });
\end{lstlisting}

\subsubsection{Upload signed url request}

\begin{lstlisting}[language=javascript]
Image.signed_put = function(file_name, 
	file_type, callback) {
    var s3 = new aws.S3();
    var s3_params = {
      Bucket: S3_BUCKET,
      Key: file_name,
      Expires: 60,
      ContentType: file_type,
      ACL: 'public-read'
    };
    s3.getSignedUrl('putObject', s3_params,
     function (err, signed_url) {
      if (err) {
        callback(err);
        return;
      }
      callback(null, signed_url);
    });
  };

  Image.remoteMethod('signed_put', {
    http: { verb: 'get' },
    accepts: [
      {arg: 'file_name', type: 'string'},
      {arg: 'file_type', type: 'string'}
    ],
    returns: {arg: 'signed_url', type: 'string'}
  });
\end{lstlisting}


\subsubsection{Delete signed url request}

\begin{lstlisting}[language=javascript]
Image.signed_delete = function(file_name, callback) {
    var s3 = new aws.S3();
    var s3_params = {
      Bucket: S3_BUCKET,
      Key: file_name
    };
    s3.getSignedUrl('deleteObject', s3_params,
      function (err, signed_url) {
      if (err) {
        callback(err);
        return;
      }
      callback(null, signed_url);
    });
  };

  Image.remoteMethod('signed_delete', {
    http: { verb: 'get' },
    accepts: {arg: 'file_name', type: 'string'},
    returns: {arg: 'signed_url', type: 'string'}
  });

\end{lstlisting}

\subsubsection{Get signed url request}

\begin{lstlisting}[language=javascript]
Image.signed_list = function (folder, callback) {
    var s3 = new aws.S3();
    var s3_params = {
      Bucket: S3_BUCKET,
      EncodingType: 'url',
      Prefix: folder,
      MaxKeys: 1000
    };
    s3.getSignedUrl('listObjects', s3_params,
     function (err, signed_url) {
      if (err) {
        callback(err);
        return;
      }
      callback(null, signed_url);
    });
  };

  Image.remoteMethod('signed_list', {
    http: { verb: 'get' },
    accepts: { arg: 'folder', type: 'string' },
    returns: { arg: 'signed_url', type: 'string' }
  });
\end{lstlisting}


\subsection{3rd step - UI components definition}


UI components definition consist of the justapposition of previously created HTML tags. In this short example it is shown the creation of an article page.
To compose the article page there's need to get article informations: title, content, author and images.
As shown below, HTML code is extremly simple: considering that even the page is a Polymer element, it's enough insert other tags in desired order. 


\begin{lstlisting}[language=html]
<link rel="import" href="../app-page/app-page.html">
<link rel="import" href="../part-jumbotron/part-jumbotron.html">
<link rel="import" href="../part-image/part-image.html">
<dom-module id="page-article">
  <template>
      <part-jumbotron id="jumbotron">
        <header id="header">
          <h1 id="title">
            <span>{{article.title}}</span>
            <span>{{article.author}}</span>
          </h1>
        </header>
      </part-jumbotron>

      <div class="container">
        <div>
          <p id= "content"> {{article.content}}</p>
        </div>
        <div class="container">
          <part-image id="image"> </part-image>
        </div> 
      </div>
  </template>
</dom-module>

<script>
  Polymer({
    attached: function() {
      this.$.image.update();
    }
  });
</script>
\end{lstlisting}



The article page component has two main HTML tags: \texttt{part-jumbotron} and \texttt{part-image}.

In \texttt{part-jumboton} article informations are showed: \texttt{{{article.title}}} and \texttt{{{article.author}}}. These informations are extrapolated from article property that is injected in the session by the router.

The other tag, \texttt{part-image}, loads and shows the article's image, by triggering other APIs: the activation of these APIs is made by the \texttt{attached} function that is triggered at page load time.



\subsection{4th step - UI components assembly}

Since a snippet is worth a thousand words, in the following the code of the pages of the app is shown. It is important to remark how easily a page can be built without writing code but assembling elements.

Tha admin part is composed by page-collection and page-model-edit. These pages are accessible via the following routes.

\begin{lstlisting}[language=html]
<x-router>
	<x-route route="/admin/:collection"page="page-collection"/>
	<x-route route="/admin/:collection/:id"page="page-model-edit"/>
</x-router>
\end{lstlisting}

Where: the parameter :collection is the name of the collection to inspect; the parameter :id is the id of the model to edit. These parameters are set as attributes of the page element.

\begin{itemize} \item \texttt{<page-collection>} Shows the models of a collection.
\begin{lstlisting}[language=html]
<template name= "page-collection">
	<api-collection-schema name="{{collection}}" 
	schema="{{schema}" />
	<api-collection-get name="{{collection}}" 
	where="{{where}}" page="{{page}}" perpage="{{perpage}}"
	items="{{items}}" count="{{count}}"/>
	<api-collection-where schema="{{schema}}" 
	where="{{where}}"/>
	<x-table schema="{{schema}}" items="{{items}}" />
	<x-pager count="{{count}}" perpage="{{perpage}}" 
	current="{{page}}"/>
</template>
\end{lstlisting}
\end{itemize}

Where: the value collection is picked from the url, via the parameter :collection; the value schema is the output of \texttt{<api-collection-schema>} and the input of \texttt{<api-collection-get>} and \texttt{<x-table>}; the value items is the output of \texttt{<api-collection-get>} and the input of \texttt{<x-table>}; the value where is the output of \texttt{<api-collection-where>} and the input of \texttt{<api-collection-get>}; the value count is the output of \texttt{<api-collection-get>} and the input of \texttt{<x-pager>}; the values perpage and page are the outputs of \texttt{<x-pager>} and the inputs of \texttt{<api-collection-get>}; every time the user (the admin) interacts with the pagination (\texttt{<x-pager>}) or the advanced search options (\texttt{<api-collection-where>}), \texttt{<api-collection-get>} regenerates the request to get the list of models using pagination and query parameters.


\begin{itemize} \item \texttt{<page-model-edit>} Shows the forms to update a model.
\begin{lstlisting}[language=html]
<template name="page-model-edit">
	<api-collection-schema name="{{collection}}"
	schema="{{schema}}"/>
	<api-model-get name="{{collection}"
	model-id="{{id}}" model="{{model}}"/>
	<x-form schema="{{schema}}" model="{{model}}"/>
	<api-model-put name="{{collection}}"
	model-id="{{id}}" model="{{model}}"/>
</template>
\end{lstlisting}
\end{itemize}

Where: the value schema is the output of \texttt{<api-collection-schema>} and the input of \texttt{<x-form>}; the value model is the output of \texttt{<api-model-get>} and \texttt{<x-form>} and the input of \texttt{<api-model-put>}. Once the page is ready (initialized and served by the local router): \texttt{<api-collection-schema>} fetch the schema; \texttt{<api-model-get>} fetch the model (a article or a tag) identified by id; \texttt{<x-form>} shows the form to edit the model. When the model changes (is updated via the form) \texttt{<api-model-put>} sends a request to the server to update the database (via the corresponding HTTP RESTful API).


The user part is essentially composed by two pages: page-articles and page-article.

\begin{lstlisting}[language=html]
<x-router>
	<x-route route="/"page=" page-articles"/>
	<x-route route="articles/:id" page=" page-article"/>
</x-router>
\end{lstlisting}

\begin{itemize} \item \texttt{<page-articles>} Shows the list of articles.
\begin{lstlisting}[language=html]
<template name="page-articles">
	<api-collection-get name="Article"
		perpage="10" page="{{page}}"
		items="{{articles}}" count="{{count}}"/>
	<template is="dom-repeat" items="{{articles}}">
		<li>{{item.title}} {{item.date}}</li>
	</template>
	<x-pager perpage="10" total="{{count}}"
		current="{{page}}"/>
</template>
\end{lstlisting}
\end{itemize}

Where: the value articles is the output of \texttt{<api-collection-get>} and the input of the \texttt{<template>} iterator; for each item in articles, a list item with the article info (title and publish-ing date) is printed; \texttt{<x-pager>} component is the same used in the page \texttt{<page-collection>}.

\begin{itemize} \item \texttt{<page-article>} Shows a article.
\begin{lstlisting}[language=html]
<template name="page-article">
	<api-model-get name="Articles" model-id="{{id}}"
	model="{{article}}"/>
	<h1>{{article.title}}</h1>
	<h2>by{{article.author}}</h2>
	<h3>on{{article.date}}</h3>
	<div>{{article.content}}</div>
</template>
\end{lstlisting}
\end{itemize}

Once \texttt{<api-model-get>} has fetched the article (identified by id), title, author, date and content of the article will be shown. It has been shown how to use \texttt{x-project} toolkit to build a simple blog application. It can be extended, adding new features, by following the 4-steps document-driven process: defining new models, generating corresponding API, defininig new UI components, assembling the UI. The growth of the complexity of the application does not affect the complexity of the development. x-project source code is published on GitHub at http://github.com/x-project.

