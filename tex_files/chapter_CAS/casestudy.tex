\section{Case Study}
\label{sec:CAS_castudy}

In this section the design and the implementation of a blog platform is presented.

\subsection{1st step - Models schemas definition}

As to a blog platform, the essential entities to be modelled are the following: Post and Tag.

\begin{lstlisting}[language=javascript]
{
	"name": "Post",
	"properties": {
		"title": {
			"type":"string"
		},
		"posted": {"type":"date"},
		"content": {"type":"text"},
		"permalink": {"type":"string"}
	},
	"relations": [
		{
			name: "tags",
			"type":"has_many","model":"Tag"}
	]
}
\end{lstlisting}

\begin{lstlisting}[language=javascript]
{
	"name": "Tag",
	"properties": {
		"name": {"type":"string"}
	}
}
\end{lstlisting}

\subsection{2nd step - HTTP RESTful API definition}

These models result in the following HTTP RESTful API, automatically generated by Loopback server.

\begin{lstlisting}[language=javascript]
	GET / api / Posts
	POST / api / Posts
	GET / api / Posts /: post_id
	PUT / api / Posts /: post_id
	DELETE / api / Posts /: post_id
	GET / api / Tags
	POST / api / Tags
	GET / api / Tags /: tag_id
	PUT / api / Tags /: tag_id
	DELETE / api / Tags /: tag_id
\end{lstlisting}

\subsection{3rd step - UI components definition}

In this simple example, there is no need to define further components besides the ones provided by the x-project toolkit.

\subsection{4th step - UI components assembly}

Since a snippet is worth a thousand words, in the following the code of the pages of the app is shown. It is important to remark how easily a page can be built without writing code but assembling elements.

Tha admin part is composed by page-collection and page-model-edit. These pages are accessible via the following routes.

\begin{lstlisting}[language=html]
<x-router>
	<x-route route="/admin/:collection"page="page-collection"/>
	<x-route route="/admin/:collection/:id"page="page-model-edit"/>
</x-router>
\end{lstlisting}

Where: the parameter :collection is the name of the collection to inspect; the parameter :id is the id of the model to edit. These parameters are set as attributes of the page element.

\begin{itemize} \texttt{<page-collection>} Shows the models of a collection.

\begin{lstlisting}[language=html]
<template name= "page-collection">
	<api-collection-schema name="{{collection}}" 
	schema="{{schema}" />
	<api-collection-get name="{{collection}}" 
	where="{{where}}" page="{{page}}" perpage="{{perpage}}"
	items="{{items}}" count="{{count}}"/>
	<api-collection-where schema="{{schema}}" 
	where="{{where}}"/>
	<x-table schema="{{schema}}" items="{{items}}" />
	<x-pager count="{{count}}" perpage="{{perpage}}" 
	current="{{page}}"/>
</template>
\end{lstlisting}

Where: the value collection is picked from the url, via the parameter :collection; the value schema is the output of \texttt{<api-collection-schema>} and the input of \texttt{<api-collection-get>} and \texttt{<x-table>}; the value items is the output of \texttt{<api-collection-get>} and the input of \texttt{<x-table>}; the value where is the output of \texttt{<api-collection-where>} and the input of \texttt{<api-collection-get>}; the value count is the output of \texttt{<api-collection-get>} and the input of \texttt{<x-pager>}; the values perpage and page are the outputs of \texttt{<x-pager>} and the inputs of \texttt{<api-collection-get>}; every time the user (the admin) interacts with the pagination (\texttt{<x-pager>}) or the advanced search options (\texttt{<api-collection-where>}), \texttt{<api-collection-get>} regenerates the request to get the list of models using pagination and query parameters.

\end{itemize}

\begin{itemize} \texttt{<page-model-edit>} Shows the forms to update a model.

\begin{lstlisting}[language=html]
<template name="page-model-edit">
	<api-collection-schema name="{collection}"
	schema="{schema}"/>
	<api-model-get name="{collection}"
	model-id="{id}" model="{model}"/>
	<x-form schema="{schema}" model="{model}"/>
	<api-model-put name="{collection}"
	model-id="{id}" model="{model}"/>
</template>
\end{lstlisting}

Where: the value schema is the output of \texttt{<api-collection-schema>} and the input of \texttt{<x-form>}; the value model is the output of \texttt{<api-model-get>} and \texttt{<x-form>} and the input of \texttt{<api-model-put>}. Once the page is ready (initialized and served by the local router): \texttt{<api-collection-schema>} fetch the schema; \texttt{<api-model-get>} fetch the model (a post or a tag) identified by id; \texttt{<x-form>} shows the form to edit the model. When the model changes (is updated via the form) \texttt{<api-model-put>} sends a request to the server to update the database (via the corresponding HTTP RESTful API).

\end{itemize}

The user part is essentially composed by two pages: page-posts and page-post.

\begin{lstlisting}[language=html]
<x-router>
	<x-route route="/"page=" page-posts"/>
	<x-route route="posts/:id" page=" page-post"/>
</x-router>
\end{lstlisting}

\begin{itemize} \texttt{<page-posts>} Shows the list of posts.

\begin{lstlisting}[language=html]
<template name= " page-posts ">
	<api-collection-get name="Posts"
		perpage="10" page="{page}"
		items="{posts}" count="{count}"/>
	<template is="dom-repeat" items="{posts}">
		<li>{item.title} {item.date}</li>
	</template>
	<x-pager perpage="10" total="{count}"
		current="{page}"/>
</template>
\end{lstlisting}

Where: the value posts is the output of \texttt{<api-collection-get>} and the input of the \texttt{<template>} iterator; for each item in posts, a list item with the post info (title and publish-ing date) is printed; \texttt{<x-pager>} component is the same used in the page \texttt{<page-collection>}.

\begin{itemize} \texttt{<page-post>} Shows a post.

\begin{lstlisting}[language=html]
<template name="page-post">
	<api-model-get name="Posts" model-id="{id}"
	model="{post}"/>
	<h1>{post.title}</h1>
	<h2>by{post.author}</h2>
	<h3>on{post.date}</h3>
	<div>{post.content}</div>
</template>
\end{lstlisting}

Once \texttt{<api-model-get>} has fetched the post (identified by id), title, author, date and content of the post will be shown. It has been shown how to use \texttt{x-project} toolkit to build a simple blog application. It can be extended, adding new features, by following the 4-steps document-driven process: defining new models, generating corresponding API, defininig new UI components, assembling the UI. The growth of the complexity of the application does not affect the complexity of the development. x-project source code is published on GitHub at http://github.com/x-project.

